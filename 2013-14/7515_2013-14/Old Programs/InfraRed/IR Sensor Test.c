#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     finbas,         sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     stop,           sensorTouch)
#pragma config(Sensor, S4,     DONOTCRASH,         sensorSONAR)
#pragma config(Motor,  mtr_S1_C1_1,     backleft,      tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     frontleft,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     flag,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     lifter,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     backright,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     frontright,    tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C4_1,    conv,                 tServoContinuousRotation)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
void initializeRobot()
{
	return;
}
task main()
{
bool phase1 = true;
while(phase1 == true)
{
bool turn = false;
bool sconv = false;
bool turn2 = false;
bool pstop = false;
  // heads towards basket slowly so it dosen't bounce off
  if (SensorValue[finbas] == 5 && sconv != true)
{
	motor[backleft] = 4;
	motor[frontleft] = 4;
	motor[backright] = 4;
  motor[frontright] = 4;
}
  // stops the robot and starts the conveyor belt
//	if (SensorValue[stop] == 1)
//{
	//sconv = true;
	//trololololololololololololololololololololololololol
//}
if (sconv == true && pstop != true) // make ut based on time note touch
{
  motor[backleft] = 0;
	motor[frontleft] = 0;
	motor[backright] = 0;
  motor[frontright] = 0;
  // add conv
  wait1Msec(800);
  pstop = true;
}
  // makes sure the robot only turns towards the basket at a 90% angle
  if (SensorValue[finbas] < 8 && SensorValue[finbas] > 5 && turn != true || SensorValue[finbas] > 2 && SensorValue[finbas] < 5 && turn != true)
 {
	motor[backleft] = 25;
	motor[frontleft] = 25;
	motor[backright] = 25;
  motor[frontright] = 25;
 } // slows down the robot in inticipation of the turn
  if (SensorValue[finbas] == 3 && turn != true || SensorValue[finbas] == 7 && turn != true)
  {
  motor[backleft] = 10;
	motor[frontleft] = 10;
	motor[backright] = 10;
  motor[frontright] = 10;
   }
   // turns right
if (SensorValue[finbas] == 8 && pstop != true)
{
	turn = true;
	motor[backleft] = 100;
	motor[frontleft] = 100;
	motor[backright] = -100;
  motor[frontright] = -100;
}
   // turns left for now we will only go right
if (SensorValue[finbas] == 2 && pstop != true)
{
	turn = true;
	motor[backleft] = -100;
	motor[frontleft] = -100;
	motor[backright] = 100;
  motor[frontright] = 100;
}
if (SensorValue[finbas] == 5 && pstop == true)
{
	turn = true;
	motor[backleft] = -100;
	motor[frontleft] = -100;
	motor[backright] = 100;
  motor[frontright] = 100;
  wait1Msec(600);
  phase1 = false;
}
}
  int distance_in_cm = 25;   // Create variable 'distance_in_cm' and initialize it to 20(cm).
  while(SensorValue[DONOTCRASH] > distance_in_cm)   /* While the Sonar Sensor readings are greater */
{
 	motor[backleft] = 100;
	motor[frontleft] = 100;
	motor[backright] = 100;
  motor[frontright] = 100;
}
motor[backleft] = 100;
motor[frontleft] = 100;
motor[backright] = -100;
motor[frontright] = -100;
wait1Msec(600);
motor[backleft] = 100;
motor[frontleft] = 100;
motor[backright] = 100;
motor[frontright] = 100;
wait1Msec(900);
motor[backleft] = 100;
motor[frontleft] = 100;
motor[backright] = -100;
motor[frontright] = -100;
wait1Msec(600);
motor[backleft] = 100;
motor[frontleft] = 100;
motor[backright] = 100;
motor[frontright] = 100;
wait1Msec(1200);
}
