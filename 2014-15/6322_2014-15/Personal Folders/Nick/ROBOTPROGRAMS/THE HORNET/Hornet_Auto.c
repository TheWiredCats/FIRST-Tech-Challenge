#pragma config(Hubs,  S1, HTServo,  HTMotor,  HTMotor,  none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorI2CMuxController)
#pragma config(Motor,  mtr_S1_C2_1,     RightENC,      tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     Right,         tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     motorF,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     Rightlift,     tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     intake,        tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C1_2,     LeftENC,       tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S2_C2_1,     Left,          tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S2_C2_2,     Leftlift,      tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S1_C1_1,    servo1,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// PURPOSE: OFFICIAL AUTONOMOUS FOR STATES ROBOT.
#include "joystickdriver.c"
float diameter = 0.10079; //m
float circumference = diameter*PI;
float rotations;
long degrees;
long encodercounts;


void forward( int distm, int speed);


task main()
{

forward(1,50);




}


void forward( int distm, int speed)
{
rotations = 10;
degrees = rotations*360;
encodercounts = degrees*4;

nMotorEncoder[RightENC] = 0;
nMotorEncoder[LeftENC] = 0;

nMotorEncoderTarget[RightENC] = 1000;
nMotorEncoderTarget[LeftENC] = 1000;

motor[RightENC] = speed;
motor[LeftENC] = speed;
motor[Left] = speed;
motor[Right] = speed;

while(nMotorRunState[RightENC] != runStateIdle && nMotorRunState[LeftENC] != runStateIdle)
{
	}
motor[RightENC] = 0;
motor[LeftENC] = 0;
motor[Left] = 0;
motor[Right] = 0;


}




//hai
